import fs from "node:fs";
import path from "node:path";
import https from "node:https";

const ROOT = path.resolve(process.cwd());

const SKY_CULTURE = "western";
const INDEX_URL = `https://raw.githubusercontent.com/Stellarium/stellarium-skycultures/master/${SKY_CULTURE}/index.json`;

const OUT_PATH = path.join(
  ROOT,
  "src",
  "data",
  "constellationLines.generated.js",
);

function fetchText(url) {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        if (
          res.statusCode &&
          res.statusCode >= 300 &&
          res.statusCode < 400 &&
          res.headers.location
        ) {
          fetchText(res.headers.location).then(resolve).catch(reject);
          return;
        }

        if (res.statusCode !== 200) {
          reject(
            new Error(
              `Failed to fetch: ${res.statusCode} ${res.statusMessage} (${url})`,
            ),
          );
          return;
        }

        res.setEncoding("utf8");
        let data = "";
        res.on("data", (chunk) => (data += chunk));
        res.on("end", () => resolve(data));
      })
      .on("error", reject);
  });
}

function stablePair(a, b) {
  return a < b ? [a, b] : [b, a];
}

function toJsLiteral(obj) {
  // Deterministic JSON-ish output (valid JS). Keeps arrays compact.
  return JSON.stringify(obj, null, 2);
}

function buildEdgesFromPolylines(polylines) {
  const edges = [];
  const seen = new Set();

  for (const poly of polylines) {
    if (!Array.isArray(poly) || poly.length < 2) continue;

    for (let i = 0; i < poly.length - 1; i++) {
      const a = Number(poly[i]);
      const b = Number(poly[i + 1]);
      if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
      if (a === b) continue;

      const [x, y] = stablePair(a, b);
      const key = `${x}-${y}`;
      if (seen.has(key)) continue;
      seen.add(key);
      edges.push([x, y]);
    }
  }

  // Keep output stable.
  edges.sort((p, q) => p[0] - q[0] || p[1] - q[1]);
  return edges;
}

async function main() {
  console.log(`Fetching Stellarium skyculture index: ${INDEX_URL}`);
  const text = await fetchText(INDEX_URL);
  const json = JSON.parse(text);

  const constellations = Array.isArray(json.constellations)
    ? json.constellations
    : [];
  if (constellations.length === 0) {
    throw new Error("No constellations found in skyculture index.json");
  }

  const mapping = {};
  for (const c of constellations) {
    const abbr = c?.iau || c?.id;
    if (!abbr || typeof abbr !== "string") continue;

    const polylines = Array.isArray(c.lines) ? c.lines : [];
    const edges = buildEdgesFromPolylines(polylines);
    if (edges.length === 0) continue;

    mapping[abbr] = edges;
  }

  const ordered = Object.fromEntries(
    Object.keys(mapping)
      .sort()
      .map((k) => [k, mapping[k]]),
  );

  const banner = `// AUTO-GENERATED FILE
//
// Source: Stellarium skyculture data (Western)
// Repo: https://github.com/Stellarium/stellarium-skycultures
// File: ${SKY_CULTURE}/index.json
//
// Generated by: node scripts/generateConstellationLines.mjs
//
// NOTE: This data has its own license/attribution requirements.
// See the skyculture's description.md in the source repo.
\n`;

  const body =
    `${banner}` +
    `export const CONSTELLATION_LINES_SOURCE = ${toJsLiteral({
      skyCulture: SKY_CULTURE,
      url: INDEX_URL,
      generatedAt: new Date().toISOString(),
    })};\n\n` +
    `export const constellationLines = ${toJsLiteral(ordered)};\n`;

  fs.mkdirSync(path.dirname(OUT_PATH), { recursive: true });
  fs.writeFileSync(OUT_PATH, body, "utf8");

  console.log(
    `Wrote ${path.relative(ROOT, OUT_PATH)} (${Object.keys(ordered).length} constellations)`,
  );
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
